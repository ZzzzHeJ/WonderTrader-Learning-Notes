---
sort: 3
---

# 编写策略

同大多数的量化框架一样，WT中的策略也采用事件驱动的方式。所谓事件驱动的意思是，策略的中逻辑的执行，是由一个个事件推动的，当一个事件发生时，策略便执行对应事件的回调函数，从而推动策略运行。

WT中共有以下回调事件

## \_\_init\_\_

学过Python的小伙伴都知道，Python中类在被创建时，会调用\_\_init\_\_函数，来接受类创建时传入的各个参数。WT中的策略其实是一个继承自BaseCtaStrategy类的子类。因此当他被创建时，便会触发\_\_init\_\_函数，用来传入参数等信息。

以demo中使用的**DualThrust.py**为例：
```python
# 继承策略基类BaseCtaStrategy
class StraDualThrust(BaseCtaStrategy):
    # 重写初始化代码，接受的参数可以自己决定
    def __init__(self, name:str, code:str, barCnt:int, period:str, days:int, k1:float, k2:float, isForStk:bool = False):
        # 初始化父类，name参数表示该策略的名称
        BaseCtaStrategy.__init__(self, name)

        # 接受参数，并把它赋值给自己的成员
        self.__days__ = days
        self.__k1__ = k1
        self.__k2__ = k2

        self.__period__ = period
        self.__bar_cnt__ = barCnt
        self.__code__ = code

        self.__is_stk__ = isForStk
```

```tip
注意，我们策略中所有的回调函数，包括__init__，均是对父类的重写。包括接受的参数与内部逻辑在内，均可以自己重写，切勿被demo中的__init__误导，误以为wt中的策略必须要接受这些参数。__init__建议接收的参数只有name，其他的均可以自己决定。
```

## on_init

在回测中，on_init是在数据回放器准备好回测数据后执行，而实盘中，则是连接到行情服务后执行。on_init的主要功能是订阅行情数据，加载外部数据等。

```python
def on_init(self, context:CtaContext):
    code = self.__code__    #品种代码
    if self.__is_stk__:
        code = code + "Q"

    #这里演示了品种信息获取的接口
    pInfo = context.stra_get_comminfo(code)
    print(pInfo)

    # 订阅K线
    context.stra_get_bars(code, self.__period__, self.__bar_cnt__, isMain = True)
    # 订阅Tick
    context.stra_sub_ticks(code)

    context.stra_log_text("DualThrust inited")
```

```tip
__init__是策略初始化时触发的，是策略第一个被触发的函数。
on_init是回测数据或行情服务准备好后触发的，是策略在接受数据前最后一个触发的函数。
```